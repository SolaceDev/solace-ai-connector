{"prompt": "Here is a structure that defines all the built-in components and transforms.\
    \ \n<transform_and_components_yaml>\ncomponent:\n- class_name: ErrorInput\n  config_parameters:\n\
    \  - default: null\n    description: Maximum rate of errors to process per second.\
    \ Any errors above this\n      rate will be dropped. If not set, all errors will\
    \ be processed.\n    name: max_rate\n    required: false\n  description: 'Receive\
    \ processing errors from the Solace AI Event Connector. Note\n    that the component_input\
    \ configuration is ignored. This component should be used\n    to create a flow\
    \ that handles errors from other flows. '\n  output_schema:\n    properties:\n\
    \      error:\n        description: Information about the error\n        properties:\n\
    \          exception:\n            description: The exception message\n      \
    \      type: string\n          message:\n            description: The error message\n\
    \            type: string\n        required:\n        - message\n        - exception\n\
    \        type: object\n      location:\n        description: The location where\
    \ the error occurred\n        properties:\n          component:\n            description:\
    \ The component name that generated the error\n            type: string\n    \
    \      flow:\n            description: The flow name of the component that generated\
    \ the error\n            type: string\n          instance:\n            description:\
    \ The instance number of the component that generated the error\n            type:\
    \ integer\n        required:\n        - flow\n        - component\n        type:\
    \ object\n      message:\n        description: The message that caused the error\n\
    \        properties:\n          payload:\n            description: The payload\
    \ of the message\n            type: string\n          previous:\n            description:\
    \ The output from the previous stage that was processed before\n             \
    \ the error\n            type: object\n          topic:\n            description:\
    \ The topic of the message\n            type: string\n          user_data:\n \
    \           description: The user data of the message that was created during\
    \ the\n              flow\n            type: object\n          user_properties:\n\
    \            description: The user properties of the message\n            type:\
    \ object\n        required: []\n        type: object\n    required:\n    - error\n\
    \    - message\n    - location\n    type: object\n- class_name: BrokerInput\n\
    \  config_parameters:\n  - description: Type of broker (Solace, MQTT, etc.)\n\
    \    name: broker_type\n    required: true\n  - description: Broker URL (e.g.\
    \ tcp://localhost:55555)\n    name: broker_url\n    required: true\n  - description:\
    \ Client username for broker\n    name: broker_username\n    required: true\n\
    \  - description: Client password for broker\n    name: broker_password\n    required:\
    \ true\n  - description: Client VPN for broker\n    name: broker_vpn\n    required:\
    \ true\n  - description: Queue name for broker\n    name: broker_queue_name\n\
    \    required: true\n  - description: Subscriptions for broker\n    name: broker_subscriptions\n\
    \    required: true\n  - default: utf-8\n    description: Encoding for the payload\
    \ (utf-8, base64, gzip, none)\n    name: payload_encoding\n    required: false\n\
    \  - default: json\n    description: Format for the payload (json, yaml, text)\n\
    \    name: payload_format\n    required: false\n  description: Connect to a messaging\
    \ broker and receive messages from it. The component\n    will output the payload,\
    \ topic, and user properties of the message.\n  output_schema:\n    properties:\n\
    \      payload:\n        type: string\n      topic:\n        type: string\n  \
    \    user_properties:\n        type: object\n    required:\n    - payload\n  \
    \  - topic\n    - user_properties\n    type: object\n- class_name: BrokerOutput\n\
    \  config_parameters:\n  - description: Type of broker (Solace, MQTT, etc.)\n\
    \    name: broker_type\n    required: true\n  - description: Broker URL (e.g.\
    \ tcp://localhost:55555)\n    name: broker_url\n    required: true\n  - description:\
    \ Client username for broker\n    name: broker_username\n    required: true\n\
    \  - description: Client password for broker\n    name: broker_password\n    required:\
    \ true\n  - description: Client VPN for broker\n    name: broker_vpn\n    required:\
    \ true\n  - default: utf-8\n    description: Encoding for the payload (utf-8,\
    \ base64, gzip, none)\n    name: payload_encoding\n    required: false\n  - default:\
    \ json\n    description: Format for the payload (json, yaml, text)\n    name:\
    \ payload_format\n    required: false\n  - default: true\n    description: Propagate\
    \ acknowledgements from the broker to the previous components\n    name: propagate_acknowledgements\n\
    \    required: false\n  description: Connect to a messaging broker and send messages\
    \ to it. Note that this\n    component requires that the data is transformed into\
    \ the input schema.\n  input_schema:\n    properties:\n      payload:\n      \
    \  description: Payload of the message sent to the broker\n        type: any\n\
    \      topic:\n        description: Topic to send the message to\n        type:\
    \ string\n      user_properties:\n        description: User properties to send\
    \ with the message\n        type: object\n    required:\n    - payload\n    -\
    \ topic\n    type: object\n- class_name: Stdout\n  config_parameters: []\n  description:\
    \ STDOUT output component\n  input_schema:\n    properties:\n      text:\n   \
    \     type: string\n    required:\n    - text\n    type: object\n- class_name:\
    \ Stdin\n  config_parameters: []\n  description: STDIN input component. The component\
    \ will prompt for input, which will\n    then be placed in the message payload\
    \ using the output schema below.\n  output_schema:\n    properties:\n      text:\n\
    \        type: string\n    required:\n    - text\n    type: object\n- class_name:\
    \ SlackInput\n  config_parameters:\n  - description: The Slack bot token to connect\
    \ to Slack.\n    name: slack_bot_token\n    type: string\n  - description: The\
    \ Slack app token to connect to Slack.\n    name: slack_app_token\n    type: string\n\
    \  - default: 20\n    description: 'The maximum file size to download from Slack\
    \ in MB. Default: 20MB'\n    name: max_file_size\n    required: false\n    type:\
    \ number\n  - default: 20\n    description: 'The maximum total file size to download\
    \ from Slack in MB. Default:\n      20MB'\n    name: max_total_file_size\n   \
    \ required: false\n    type: number\n  description: Slack input component. The\
    \ component connects to Slack using the Bolt\n    API and receives messages from\
    \ Slack channels.\n  output_schema:\n    properties:\n      event:\n        properties:\n\
    \          channel:\n            type: string\n          channel_type:\n     \
    \       type: string\n          client_msg_id:\n            type: string\n   \
    \       event_ts:\n            type: string\n          files:\n            items:\n\
    \              properties:\n                content:\n                  type:\
    \ string\n                filetype:\n                  type: string\n        \
    \        mime_type:\n                  type: string\n                name:\n \
    \                 type: string\n                size:\n                  type:\
    \ number\n              type: object\n            type: array\n          mentions:\n\
    \            items:\n              type: string\n            type: array\n   \
    \       subtype:\n            type: string\n          text:\n            type:\
    \ string\n          ts:\n            type: string\n          type:\n         \
    \   type: string\n          user_email:\n            type: string\n          user_id:\n\
    \            type: string\n        type: object\n    required:\n    - event\n\
    \    type: object\n- class_name: UserProcessor\n  config_parameters: []\n  description:\
    \ 'A component that allows the processing stage to be defined in the\n    configuration\
    \ file using ''invoke'' statements. The configuration must be specified\n    with\
    \ the ''component_processing:'' property alongside the ''component_module:''\n\
    \    property in the component''s configuration. The input and output schemas\
    \ are free-form.\n    The user-defined processing must line up with the input\
    \ '\n  input_schema:\n    properties: {}\n    type: object\n  output_schema:\n\
    \    properties: {}\n    type: object\n  short_description: A component that allows\
    \ the processing stage to be defined in\n    the configuration file.\n- class_name:\
    \ Aggregate\n  config_parameters:\n  - default: 10\n    description: Number of\
    \ input messages to aggregate before sending an output message\n    name: max_items\n\
    \    required: false\n    type: integer\n  - default: 1000\n    description: Number\
    \ of milliseconds to wait before sending an output message\n    name: max_time_ms\n\
    \    required: false\n    type: integer\n  description: Take multiple messages\
    \ and aggregate them into one. The output of this\n    component is a list of\
    \ the exact structure of the input data.\n  input_schema:\n    description: The\
    \ input message to be aggregated\n    properties: {}\n    type: object\n  output_schema:\n\
    \    description: The aggregated messages\n    items:\n      type: object\n  \
    \  type: array\n  short_description: Aggregate messages into one message.\n- class_name:\
    \ PassThrough\n  config_parameters: []\n  description: What goes in comes out\n\
    \  input_schema:\n    properties: {}\n    type: object\n  output_schema:\n   \
    \ properties: {}\n    type: object\n- class_name: Delay\n  config_parameters:\n\
    \  - default: 1\n    description: The delay in seconds\n    name: delay\n    type:\
    \ number\n  description: 'A simple component that simply passes the input to the\
    \ output, but\n    with a configurable delay. Note that it will not service the\
    \ next input until\n    the delay has passed. If this component has num_instances\
    \ > 1, each instance will\n    run in parallel. '\n  input_schema:\n    properties:\
    \ {}\n    type: object\n  output_schema:\n    properties: {}\n    type: object\n\
    \  short_description: A simple component that simply passes the input to the output,\n\
    \    but with a configurable delay.\n- class_name: Iterate\n  config_parameters:\
    \ []\n  description: Take a single message that is a list and output each item\
    \ in that list\n    as a separate message\n  input_schema:\n    items:\n     \
    \ type: object\n    type: array\n  output_schema:\n    properties: {}\n    type:\
    \ object\n- class_name: MessageFilter\n  config_parameters:\n  - description:\
    \ A dynmaic invoke configuration that will return true if message should\n   \
    \   be passed or false to drop it\n    name: filter_expression\n    required:\
    \ true\n  description: A filtering component. This will apply a user configurable\
    \ expression.\n    If the expression evaluates to True, the message will be passed\
    \ on. If the expression\n    evaluates to False, the message will be discarded.\
    \ If the message is discarded,\n    any previous components that require an acknowledgement\
    \ will be acknowledged.\n  input_schema:\n    properties: {}\n    type: object\n\
    \  output_schema:\n    properties: {}\n    type: object\n- class_name: LangChainEmbeddings\n\
    \  config_parameters:\n  - description: The chat model module - e.g. 'langchain_openai.chat_models'\n\
    \    name: langchain_module\n    required: true\n    type: string\n  - description:\
    \ The chat model class to use - e.g. ChatOpenAI\n    name: langchain_class\n \
    \   required: true\n    type: string\n  - description: Model specific configuration\
    \ for the chat model. See documentation\n      for valid parameter names.\n  \
    \  name: langchain_component_config\n    required: true\n    type: object\n  description:\
    \ Provide access to all the LangChain Text Embeddings components via\n    configuration\n\
    \  input_schema:\n    properties:\n      text:\n        description: The text\
    \ to embed\n        type: string\n      type:\n        description: 'The type\
    \ of embedding to use: ''document'' or ''query'' - default\n          is ''document'''\n\
    \        type: string\n    required:\n    - text\n    type: object\n  output_schema:\n\
    \    properties:\n      embedding:\n        description: A list of floating point\
    \ numbers representing the embedding.\n          Its length is the size of vector\
    \ that the embedding model produces\n        items:\n          type: float\n \
    \       type: array\n    required:\n    - embedding\n    type: object\n  short_description:\
    \ Provide access to all the LangChain Text Embeddings components\n    via configuration\n\
    - class_name: LangChainVectorStoreDelete\n  config_parameters:\n  - description:\
    \ The vector store library path - e.g. 'langchain_community.vectorstores'\n  \
    \  name: vector_store_component_path\n    required: true\n  - description: The\
    \ vector store to use - e.g. 'Pinecone'\n    name: vector_store_component_name\n\
    \    required: true\n  - description: Model specific configuration for the vector\
    \ store. See LangChain\n      documentation for valid parameter names for this\
    \ specific component (e.g. https://python.langchain.com/docs/integrations/vectorstores/pinecone).\n\
    \    name: vector_store_component_config\n    required: true\n  - description:\
    \ The name of the index to use\n    name: vector_store_index_name\n    required:\
    \ false\n  - description: The embedding library path - e.g. 'langchain_community.embeddings'\n\
    \    name: embedding_component_path\n    required: true\n  - description: The\
    \ embedding model to use - e.g. BedrockEmbeddings\n    name: embedding_component_name\n\
    \    required: true\n  - description: Model specific configuration for the embedding\
    \ model. See documentation\n      for valid parameter names.\n    name: embedding_component_config\n\
    \    required: true\n  - allow_source_expression: true\n    description: List\
    \ of ids to delete from the vector store.\n    name: delete_ids\n    required:\
    \ false\n  - allow_source_expression: true\n    description: Keyword arguments\
    \ to pass to the delete method of the vector store.See\n      documentation for\
    \ valid parameter names.\n    name: delete_kwargs\n    required: true\n  description:\
    \ This component allows for entries in a LangChain Vector Store to be\n    deleted.\
    \ This is needed for the continued maintenance of the vector store. Due\n    to\
    \ the nature of langchain vector stores, you need to specify an embedding component\n\
    \    even though it is not used in this component.\n  input_schema:\n    properties:\n\
    \      metadata:\n        description: 'Metadata to associate with the text in\
    \ the vector store. '\n        type: object\n      text:\n        description:\
    \ The text to embed\n        type: string\n    required:\n    - text\n    type:\
    \ object\n  output_schema:\n    properties: {}\n    type: object\n- class_name:\
    \ LangChainChatModel\n  config_parameters:\n  - description: The chat model module\
    \ - e.g. 'langchain_openai.chat_models'\n    name: langchain_module\n    required:\
    \ true\n  - description: The chat model class to use - e.g. ChatOpenAI\n    name:\
    \ langchain_class\n    required: true\n  - description: Model specific configuration\
    \ for the chat model. See documentation\n      for valid parameter names.\n  \
    \  name: langchain_component_config\n    required: true\n  - description: The\
    \ response format for this LLM request. This can be 'json', 'yaml',\n      or\
    \ 'text'. If set to 'json' or 'yaml', the response will be parsed by the appropriate\n\
    \      parser and the fields will be available in the response object. If set\
    \ to 'text',\n      the response will be returned as a string.\n    name: llm_response_format\n\
    \    required: false\n  description: Provide access to all the LangChain chat\
    \ models via configuration\n  input_schema:\n    properties:\n      messages:\n\
    \        items:\n          properties:\n            content:\n              description:\
    \ The content of the LLM message\n              type: string\n            role:\n\
    \              description: The role of the LLM message (user, assistant, system)\n\
    \              type: string\n          required:\n          - content\n      \
    \    type: object\n        type: array\n    required:\n    - messages\n    type:\
    \ object\n  output_schema:\n    description: The result of the chat model invocation.\
    \ If a format is specified,\n      then the result text will be parsed and the\
    \ fields will be available in the\n      response object.\n    properties:\n \
    \     result:\n        type: string\n    required:\n    - result\n    type: object\n\
    - class_name: LangChainVectorStoreEmbeddingsIndex\n  config_parameters:\n  - description:\
    \ The vector store library path - e.g. 'langchain_community.vectorstores'\n  \
    \  name: vector_store_component_path\n    required: true\n  - description: The\
    \ vector store to use - e.g. 'Pinecone'\n    name: vector_store_component_name\n\
    \    required: true\n  - description: Model specific configuration for the vector\
    \ store. See LangChain\n      documentation for valid parameter names for this\
    \ specific component (e.g. https://python.langchain.com/docs/integrations/vectorstores/pinecone).\n\
    \    name: vector_store_component_config\n    required: true\n  - description:\
    \ The name of the index to use\n    name: vector_store_index_name\n    required:\
    \ false\n  - description: The embedding library path - e.g. 'langchain_community.embeddings'\n\
    \    name: embedding_component_path\n    required: true\n  - description: The\
    \ embedding model to use - e.g. BedrockEmbeddings\n    name: embedding_component_name\n\
    \    required: true\n  - description: Model specific configuration for the embedding\
    \ model. See documentation\n      for valid parameter names.\n    name: embedding_component_config\n\
    \    required: true\n  description: Use LangChain Vector Stores to index text\
    \ for later semantic searches.\n    This will take text, run it through an embedding\
    \ model and then store it in a\n    vector database.\n  input_schema:\n    properties:\n\
    \      metadatas:\n        items:\n          type: object\n        type: array\n\
    \      texts:\n        items:\n          type: string\n        type: array\n \
    \   required:\n    - texts\n    type: object\n  output_schema:\n    properties:\
    \ {}\n    required:\n    - results\n    type: object\n- class_name: LangChainVectorStoreEmbeddingsSearch\n\
    \  config_parameters:\n  - description: The vector store library path - e.g. 'langchain_community.vectorstores'\n\
    \    name: vector_store_component_path\n    required: true\n  - description: The\
    \ vector store to use - e.g. 'Pinecone'\n    name: vector_store_component_name\n\
    \    required: true\n  - description: Model specific configuration for the vector\
    \ store. See LangChain\n      documentation for valid parameter names for this\
    \ specific component (e.g. https://python.langchain.com/docs/integrations/vectorstores/pinecone).\n\
    \    name: vector_store_component_config\n    required: true\n  - description:\
    \ The name of the index to use\n    name: vector_store_index_name\n    required:\
    \ false\n  - description: The embedding library path - e.g. 'langchain_community.embeddings'\n\
    \    name: embedding_component_path\n    required: true\n  - description: The\
    \ embedding model to use - e.g. BedrockEmbeddings\n    name: embedding_component_name\n\
    \    required: true\n  - description: Model specific configuration for the embedding\
    \ model. See documentation\n      for valid parameter names.\n    name: embedding_component_config\n\
    \    required: true\n  - description: The maximum number of results to return\n\
    \    name: max_results\n    required: true\n  - default: true\n    description:\
    \ Set to False if you don't want to combine all the context from the\n      same\
    \ source. Default is True\n    name: combine_context_from_same_source\n    required:\
    \ false\n  description: Use LangChain Vector Stores to search a vector store with\
    \ a semantic\n    search. This will take text, run it through an embedding model\
    \ with a query embedding\n    and then find the closest matches in the store.\n\
    \  input_schema:\n    properties:\n      text:\n        type: string\n    required:\n\
    \    - text\n    type: object\n  output_schema:\n    properties:\n      results:\n\
    \        properties:\n          matches:\n            items:\n              properties:\n\
    \                metadata:\n                  type: object\n                score:\n\
    \                  type: float\n                text:\n                  type:\
    \ string\n              required:\n              - text\n              type: object\n\
    \            type: array\n        type: object\n    required:\n    - results\n\
    \    type: object\ntransform:\n- class_name: MapTransform\n  config_parameters:\n\
    \  - description: Select the list to copy from\n    name: source_list_expression\n\
    \    required: true\n    type: string|invoke_expression\n  - description: 'A field\
    \ to copy. All normal source_expression options are available,\n      allowing\
    \ you to use the source list as the iterator, but copy the same value\n      from\
    \ elsewhere in the message over and over. Also, two other expression datatypes\n\
    \      are available: ''item'' and ''index''. ''item'' allows you to select from\
    \ the\n      source list entry itself (e.g. item:field_name). ''index'' allows\
    \ you to select\n      the index of the source list.'\n    name: source_expression\n\
    \    required: true\n    type: string|invoke_expression\n  - description: An optional\
    \ invoke function to process the source data before it\n      is placed in the\
    \ destination list\n    name: processing_function\n    required: false\n    type:\
    \ invoke_expression\n  - description: The list to copy the item into\n    name:\
    \ dest_list_expression\n    required: true\n    type: string|invoke_expression\n\
    \  - description: The field within the dest list to copy the item into\n    name:\
    \ dest_expression\n    required: false\n    type: string|invoke_expression\n \
    \ description: \"This is a map transform where a list is iterated over. For each\
    \ item,\\\n    \\ it is possible to take a value from either the source list (or\
    \ anywhere else\\\n    \\ in the message), optionally process it and then put\
    \ it in the same index in\\\n    \\ the destination list. If the destination list\
    \ is shorter than the source list,\\\n    \\ the destination list will be extended\
    \ to match the length of the source list.\\\n    \\ In the processing function,\
    \ you have access to the following keyword arguments:\\n\\\n    \\n * index: The\
    \ index of the current item in the source list\\n * current_value:\\\n    \\ The\
    \ value of the current item in the source list\\n * source_list: The source\\\n\
    \    \\ list\\n\\nThese should be accessed using `source_expression(keyword_args:<value\\\
    \n    \\ name>)`. For example, `source_expression(keyword_args:current_value)`.\
    \ See the\\\n    \\ example below for more detail.\"\n  example_config: \"\\n```\
    \    \\n    input_transforms:\\n      - type: map\\n        source_list_expression:\\\
    \n    \\ input.payload:my_obj.my_list\\n        source_expression: item.my_val\\\
    n     \\\n    \\   processing_function:\\n          invoke:\\n            module:\
    \ invoke_functions\\n\\\n    \\            function: add\\n              params:\\\
    n                positional:\\n\\\n    \\                  - source_expression(keyword_args:current_value)\\\
    n         \\\n    \\         - 2\\n        dest_expression: user_data.output:new_list\\\
    n```\\nThis transform\\\n    \\ would take a payload like this:\\n\\n```\\n  \
    \  {\\n      \\\"my_obj\\\": {\\n       \\\n    \\ \\\"my_list\\\": [\\n     \
    \     {\\\"my_val\\\": 1},\\n          {\\\"my_val\\\": 2},\\n   \\\n    \\  \
    \     {\\\"my_val\\\": 3}\\n        ],\\n      }\\n    }\\n```\\nand produce an\
    \ object\\\n    \\ like this:\\n\\n```\\n    user_data.output:\\n    {\\n    \
    \    new_list: [3, 4, 5]\\n\\\n    \\    }\\n```\\n\"\n  short_description: This\
    \ is a map transform where a list is iterated over, processed\n    and then placed\
    \ at the same index in the destination list.\n- class_name: CopyListItemTransform\n\
    \  config_parameters:\n  - description: Select the list to copy from\n    name:\
    \ source_expression\n    required: true\n    type: string|invoke_expression\n\
    \  - description: The field within that list to select\n    name: source_property\n\
    \    required: true\n    type: string|invoke_expression\n  - description: The\
    \ list to copy the item into\n    name: dest_expression\n    required: true\n\
    \    type: string|invoke_expression\n  - description: The field within the dest\
    \ list to copy the item into\n    name: dest_property\n    required: false\n \
    \   type: string|invoke_expression\n  description: 'Select a source list. Iterate\
    \ over the list and copy the value of\n    a field to a destination list at the\
    \ same index. This can be used to create multiple\n    lists from a single list\
    \ or vice versa. NOTE: this transform is deprecated - use\n    ''map'' instead.'\n\
    - class_name: AppendTransform\n  config_parameters:\n  - description: The field\
    \ to append to the destination list.\n    name: source_expression\n    required:\
    \ true\n    type: string|invoke_expression\n  - description: The field to append\
    \ the source value to.\n    name: dest_expression\n    required: true\n    type:\
    \ string|invoke_expression\n  description: 'Select a source value and append it\
    \ to a destination list. '\n- class_name: ReduceTransform\n  config_parameters:\n\
    \  - description: Select the list to iterate over\n    name: source_list_expression\n\
    \    required: true\n    type: string|invoke_expression\n  - description: The\
    \ field in the source list to accumulate\n    name: source_expression\n    required:\
    \ false\n    type: string|invoke_expression\n  - description: The invoke expression\
    \ to use to accumulate the values\n    name: accumulator_function\n    required:\
    \ true\n    type: invoke_expression\n  - description: The initial value for the\
    \ accumulator as a source_expression\n    name: initial_value\n    required: true\n\
    \    type: string|invoke_expression\n  - description: The field to store the accumulated\
    \ value\n    name: dest_expression\n    required: true\n    type: string|invoke_expression\n\
    \  description: \"This is a reduce transform where a list is iterated over. For\
    \ each\\\n    \\ item, it is possible to take a value from either the source list\
    \ (or anywhere\\\n    \\ else in the message) and accumulate it in the accumulator.\
    \ The accumulated value\\\n    \\ will then be stored in the dest_expression.\\\
    n\\nIn the accumulator function,\\\n    \\ you have access to the following keyword\
    \ arguments:\\n\\n * index: The index of\\\n    \\ the current item in the source\
    \ list\\n * accumulated_value: The current accumulated\\\n    \\ value\\n * current_value:\
    \ The value of the current item in the source list\\n\\\n    \\ * source_list:\
    \ The source list\\n\\nThese should be accessed using `source_expression(keyword_args:<value\\\
    \n    \\ name>)`. For example, `source_expression(keyword_args:current_value)`.\
    \ See the\\\n    \\ example below for more detail.\"\n  example_config: \"\\n```\
    \    \\n    input_transforms:\\n      - type: reduce\\n      \\\n    \\  source_list_expression:\
    \ input.payload:my_obj.my_list\\n        source_expression:\\\n    \\ item.my_val\\\
    n        initial_value: 0\\n        accumulator_function:\\n     \\\n    \\  \
    \   invoke:\\n            module: invoke_functions\\n            function: add\\\
    n\\\n    \\              params:\\n                positional:\\n            \
    \      - source_expression(keyword_args:accumulated_value)\\n\\\n    \\      \
    \            - source_expression(keyword_args:current_value)\\n        dest_expression:\\\
    \n    \\ user_data.output:my_obj.sum\\n```\\nThis transform would take a payload\
    \ like this:\\n\\\n    \\n```\\n    {\\n      \\\"my_obj\\\": {\\n        \\\"\
    my_list\\\": [\\n          {\\\"my_val\\\"\\\n    : 1},\\n          {\\\"my_val\\\
    \": 2},\\n          {\\\"my_val\\\": 3}\\n        ],\\n   \\\n    \\   }\\n  \
    \  }\\n```\\nand produce an object like this:\\n\\n```\\n    user_data.output:\\\
    n\\\n    \\    {\\n      \\\"my_obj\\\": {\\n        \\\"sum\\\": 6\\n      }\\\
    n    }\\n```\\n    \"\n  short_description: Reduce a list to a single value\n\
    - class_name: CopyTransform\n  config_parameters:\n  - description: The field\
    \ to copy from.\n    name: source_expression\n    required: true\n    type: string|invoke_expression\n\
    \  - description: The field to copy the source value to.\n    name: dest_expression\n\
    \    required: true\n    type: string|invoke_expression\n  description: Copy Transform\
    \ - copy a value from one field to another.\n- class_name: FilterTransform\n \
    \ config_parameters:\n  - description: Select the list to iterate over\n    name:\
    \ source_list_expression\n    required: true\n    type: string|invoke_expression\n\
    \  - description: The field in the source list to accumulate\n    name: source_expression\n\
    \    required: false\n    type: string|invoke_expression\n  - description: The\
    \ invoke function to use to filter the list\n    name: filter_function\n    required:\
    \ true\n    type: invoke_expression\n  - description: The list to copy the item\
    \ into\n    name: dest_list_expression\n    required: true\n    type: string|invoke_expression\n\
    \  - description: The field within the dest list to copy the item into\n    name:\
    \ dest_expression\n    required: false\n    type: string|invoke_expression\n \
    \ description: \"This is a filter transform where a list is iterated over. For\
    \ each\\\n    \\ item, the provided filter_functions is run. If it evaluates to\
    \ True then the\\\n    \\ item is copied to the destination list. If it evaluates\
    \ to False then the item\\\n    \\ is not copied to the destination list.\\n\\\
    nIn the filter function, you have access\\\n    \\ to the following keyword arguments:\\\
    n\\n * index: The index of the current item\\\n    \\ in the source list\\n *\
    \ current_value: The value of the current item in the source\\\n    \\ list\\\
    n * source_list: The source list\\n\\nThese should be accessed using `source_expression(keyword_args:<value\\\
    \n    \\ name>)`. For example, `source_expression(keyword_args:current_value)`.\
    \ See the\\\n    \\ example below for more detail.\"\n  example_config: \"\\n```\
    \    \\n    input_transforms:\\n      - type: filter\\n      \\\n    \\  source_list_expression:\
    \ input.payload:my_obj.my_list\\n        source_expression:\\\n    \\ item\\n\
    \        filter_function:\\n          invoke:\\n            module: invoke_functions\\\
    n\\\n    \\            function: greater_than\\n              params:\\n     \
    \           positional:\\n\\\n    \\                  - source_expression(keyword_args:current_value.my_val)\\\
    n  \\\n    \\                - 2\\n        dest_expression: user_data.output:new_list\\\
    n```\\n\\\n    This transform would take a payload like this:\\n\\n```\\n    {\\\
    n      \\\"my_obj\\\"\\\n    : {\\n        \\\"my_list\\\": [\\n          {\\\"\
    my_val\\\": 1},\\n          {\\\"my_val\\\"\\\n    : 2},\\n          {\\\"my_val\\\
    \": 3},\\n          {\\\"my_val\\\": 4}\\n        ],\\n   \\\n    \\   }\\n  \
    \  }\\n```\\nand produce an object like this:\\n\\n```\\n    user_data.output:\\\
    n\\\n    \\    {\\n        new_list: [\\n          {\\\"my_val\\\": 3},\\n   \
    \       {\\\"my_val\\\"\\\n    : 4}\\n        ],\\n    }\\n```\\n\"\n  short_description:\
    \ Filter a list based on a filter function\n\n</transform_and_components_yaml>\n\
    \nHere is the markdown documentation for the configuration file: \n<markdown_documentation>\n\
    # Configuration for the AI Event Connector\n\nThe AI Event Connector is highly\
    \ configurable. You can define the components of each flow, the queue depths between\
    \ them, and the number of instances of each component. The configuration is done\
    \ through a YAML file that is loaded when the connector starts. This allows you\
    \ to easily change the configuration without having to modify the code.\n\n##\
    \ Configuration File Format and Rules\n\nThe configuration file is a YAML file\
    \ that is loaded when the connector starts. \n\n### Special values\n\nWithin the\
    \ configuration, you can have simple static values, environment variables, or\
    \ dynamic values using the `invoke` keyword.\n\n#### Environment Variables\n\n\
    You can use environment variables in the configuration file by using the `${}`\
    \ syntax. For example, if you have an environment variable `MY_VAR` you can use\
    \ it in the configuration file like this:\n\n```yaml\nmy_key: ${MY_VAR}\n```\n\
    \n#### Dynamic Values (invoke keyword)\n\nYou can use dynamic values in the configuration\
    \ file by using the `invoke` keyword. This allows you to do such things as import\
    \ a module, instantiate a class and call a function to get the value. For example,\
    \ if you want to get the operating system type you can use it in the configuration\
    \ file like this:\n\n```yaml\nos_type: \n  invoke:\n    module: platform\n   \
    \ function: system\n```\n\nAn `invoke` block works by specifying an 'object' to\
    \ act on with one (and only one) of the following keys:\n- `module`: The name\
    \ of the module to import in normal Python import syntax  (e.g. `os.path`)\n-\
    \ `object`: An object to call a function on or get an attribute from. Note that\
    \ this must have an `invoke` block itself to create the object. \nIt is also acceptable\
    \ to specify neither `module` nor `object` if you are calling a function that\
    \ is in the global namespace.\n\nIn addition to the object specifier, you can\
    \ specify one (and only one) of the following keys:\n- `function`: The name of\
    \ the function to call on the object\n- `attribute`: The name of the attribute\
    \ to get from the object\n\nIn the case of a function, you can also specify a\
    \ `params` key to pass parameters to the function. The params value has the following\
    \ keys:\n- `positional`: A list of positional parameters to pass to the function\n\
    - `keyword`: A dictionary of keyword parameters to pass to the function\n\n`invoke`\
    \ blocks can be nested to build up complex objects and call functions on them.\n\
    \nHere is an example of a complex `invoke` block that could be used to get AWS\
    \ credentials:\n\n```yaml\n  # Get AWS credentials and give it a name to reference\
    \ later\n  - aws_credentials: &aws_credentials\n      invoke:\n        object:\n\
    \          invoke:\n            # import boto3\n            module: boto3\n  \
    \          # Get the session object -> boto3.Session()\n            function:\
    \ Session\n        # Call the get_credentials function on the session object ->\
    \ session.get_credentials()\n        function: get_credentials\n\n  - aws_4_auth:\n\
    \      invoke:\n        # import requests_aws4auth\n        module: requests_aws4auth\n\
    \        # Get the AWS4Auth object -> requests_aws4auth.AWS4Auth(<params from\
    \ below>)\n        function: AWS4Auth\n        params:\n          positional:\n\
    \            # Access key\n            - invoke:\n                object: *aws_credentials\n\
    \                attribute: access_key\n            # Secret key\n           \
    \ - invoke:\n                object: *aws_credentials\n                attribute:\
    \ secret_key\n            # Region (from environment variable)\n            -\
    \ ${AWS_REGION}\n            # Service name (from environment variable)\n    \
    \        - ${AWS_SERVICE}\n          keyword:\n            # Pass the session\
    \ token if it exists -> session_token=<session token>\n            session_token:\n\
    \              invoke:\n                object: *aws_credentials\n           \
    \     attribute: token\n```\n\n##### invoke_functions\n\nThere is a module named\
    \ `invoke_functions` that has a list of functions that can take the place of python\
    \ operators. This is useful for when you want to use an operator in a configuration\
    \ file. The following functions are available:\n- `add`: param1 + param2 - can\
    \ be used to add or concatenate two strings or lists\n- `append`: Append the second\
    \ value to the first\n- `subtract`: Subtract the second number from the first\n\
    - `multiply`: Multiply two numbers together\n- `divide`: Divide the first number\
    \ by the second\n- `modulus`: Get the modulus of the first number by the second\n\
    - `power`: Raise the first number to the power of the second\n- `equal`: Check\
    \ if two values are equal\n- `not_equal`: Check if two values are not equal\n\
    - `greater_than`: Check if the first value is greater than the second\n- `greater_than_or_equal`:\
    \ Check if the first value is greater than or equal to the second\n- `less_than`:\
    \ Check if the first value is less than the second\n- `less_than_or_equal`: Check\
    \ if the first value is less than or equal to the second\n- `and_op`: Check if\
    \ both values are true\n- `or_op`: Check if either value is true\n- `not_op`:\
    \ Check if the value is false\n- `in_op`: Check if the first value is in the second\
    \ value\n- `negate`: Negate the value\n- `empty_list`: Return an empty list\n\
    - `empty_dict`: Return an empty dictionary\n- `empty_string`: Return an empty\
    \ string\n- `empty_set`: Return an empty set\n- `empty_tuple`: Return an empty\
    \ tuple\n- `empty_float`: Return 0.0\n- `empty_int`: Return 0\n\nHere is an example\
    \ of using the `invoke_functions` module to do some simple operations:\n\n```yaml\n\
    \  # Use the invoke_functions module to do some simple operations\n  - simple_operations:\n\
    \      invoke:\n        module: invoke_functions\n        function: add\n    \
    \    params:\n          positional:\n            - 1\n            - 2\n```\n\n\
    ##### source_expression()\n\nIf the `invoke` block is used within an area of the\
    \ configuration that relates to message processing \n(e.g. input_transforms),\
    \ an invoke function call can use the special function `source_expression()` for\
    \ \nany of its parameters. This function will be replaced with the value of the\
    \ source expression at runtime.\nIt is an error to use `source_expression()` outside\
    \ of a message processing.\n\nExample:\n```yaml\n-flows:\n  -my_flow:\n    -my_component:\n\
    \      input_transforms:\n        -type: copy\n         source_expression: \n\
    \            invoke:\n              module: invoke_functions\n              function:\
    \ add\n              params:\n                positional:\n                  -\
    \ source_expression(input.payload:my_obj.val1)\n                  - 2\n      \
    \   dest_expression: user_data.my_obj:result\n```\n\nIn the above example, the\
    \ `source_expression()` function is used to get the value of `input.payload:my_obj.val1`\
    \ and add 2 to it.\n\n##### user_processor component and invoke\n\nThe `user_processor`\
    \ component is a special component that allows you to define a user-defined function\
    \ to process the message. This is useful for when you want to do some processing\
    \ on the input message that is not possible with the built-in transforms or other\
    \ components. In order to specify the user-defined function, you must define the\
    \ `component_processing` property with an `invoke` block. \n\nHere is an example\
    \ of using the `user_processor` component with an `invoke` block:\n\n```yaml\n\
    \  - my_user_processor:\n      component_name: my_user_processor\n      component_module:\
    \ user_processor\n      component_processing:\n        invoke:\n          module:\
    \ my_module\n          function: my_function\n          params:\n            positional:\n\
    \              - source_expression(input.payload:my_key)\n              - 2\n\
    ```\n\n\n\n\n\n## Configuration File Structure\n\nThe configuration file is a\
    \ YAML file with these top-level keys:\n\n- `log`: Configuration of logging for\
    \ the connector\n- `shared_config`: Named configurations that can be used by multiple\
    \ components later in the file\n- `flows`: A list of flow configurations. \n\n\
    ### Log Configuration\n\nThe `log` configuration section is used to configure\
    \ the logging for the connector. It configures the logging behaviour for stdout\
    \ and file logs. It has the following keys:\n\n- `stdout_log_level`: <DEBUG|INFO|WARNING|ERROR|CRITICAL>\
    \ - The log level for the stdout log\n- `log_file_level`: <DEBUG|INFO|WARNING|ERROR|CRITICAL>\
    \ - The log level for the file log\n- `log_file`: <string> - The file to log to.\
    \ If not specified, no file logging will be done\n\nHere is an example of a log\
    \ configuration:\n\n```yaml\nlog:\n  stdout_log_level: INFO\n  log_file_level:\
    \ DEBUG\n  log_file: /var/log/ai_event_connector.log\n```\n\n### Shared Configurations\n\
    \nThe `shared_config` section is used to define configurations that can be used\
    \ by multiple components later in the file. It is a dictionary of named configurations.\
    \ Each named configuration is a dictionary of configuration values. Here is an\
    \ example of a shared configuration:\n\n```yaml\nshared_config:\n  my_shared_config:\
    \ &my_shared_config\n    my_key: my_value\n    my_other_key: my_other_value\n\
    ```\n\nLater in the file, you can reference this shared configuration like this:\n\
    \n```yaml\n  - my_component:\n      <<: *my_shared_config\n      my_key: my_new_value\n\
    ```\n\n### Flow Configuration\n\nThe `flows` section is a list of flow configurations.\
    \ Each flow configuration is a dictionary with the\nfollowing keys:\n- `name`:\
    \ <string> - The unique name of the flow\n- `components`: A list of component\
    \ configurations\n\n#### Component Configuration\n\nEach component configuration\
    \ is a dictionary with the following keys:\n- `component_name`: <string> - The\
    \ unique name of the component within the flow\n- `component_module`: <string>\
    \ - The module that contains the component class (python import syntax)\n- `component_config`:\
    \ <dictionary> - The configuration for the component. Its format is specific to\
    \ the component\n- `input_transforms`: <list> - A list of transforms to apply\
    \ to the input message before sending it to the component\n- `component_input`:\
    \ <dictionary> - A source_expression or source_value to use as the input to the\
    \ component. \n- `queue_depth`: <int> - The depth of the input queue for the component\n\
    - `num_instances`: <int> - The number of instances of the component to run\n\n\
    **Note: For a list of all built-in components, see the [Components](components/index.md)\
    \ documentation.**\n\n##### component_config\n\nThe `component_config` is a dictionary\
    \ of configuration values specific to the component. The format of this dictionary\
    \ is specific to the component. You must refer to the component's documentation\
    \ for the specific configuration values.\n\n##### input_transforms\n\nThe `input_transforms`\
    \ is a list of transforms to apply to the input message before sending it to the\
    \ component. Each transform is a dictionary with the following keys:\n- `type`:\
    \ <string> - The type of transform\n- `source_expression|source_value`: <string>\
    \ - The source expression or value to use as the input to the transform\n- `dest_expression`:\
    \ <string> - The destination expression for where to store the transformation\
    \ output\n\nThe following transform modules are available:\n- `copy`: Copy the\
    \ source value to the destination\n\nHere is an example of a component configuration\
    \ with input transforms:\n\n```yaml\n  - my_component:\n      component_module:\
    \ my_module.my_component\n      component_config:\n        my_key: my_value\n\
    \      input_transforms:\n        - type: copy\n          # Extract the my_key\
    \ value from the input payload\n          source_expression: input.payload:my_key\n\
    \          # Store the value in the newly created my_obj object in the my_keys\
    \ list \n          # at index 2 (i.e. my_obj.my_keys[2].my_key = input.payload.my_key)\n\
    \          dest_expression: user_data.my_obj:my_keys.2.my_key\n```\n\n###### Built-in\
    \ Transforms\n\nThe AI Event Connector comes with a number of built-in transforms\
    \ that can be used to process messages. For a list of all built-in transforms,\
    \ see the [Transforms](transforms/index.md) documentation.\n\n##### component_input\n\
    \nThe `component_input` is a dictionary with one (and only one) of the following\
    \ keys:\n- `source_expression`: <string> - An expression to use as the input to\
    \ the component (see below for expression syntax)\n- `source_value`: <string>\
    \ - A value to use as the input to the component. \n\nNote that, as for all values\
    \ in the config file, you can use the `invoke` keyword to get dynamic values\n\
    \nHere is an example of a component configuration with a source expression:\n\n\
    ```yaml\n  - my_component:\n      component_module: my_module.my_component\n \
    \     component_config:\n        my_key: my_value\n      component_input:\n  \
    \      source_expression: input.payload:my_key\n```\n\n##### queue_depth\n\nThe\
    \ `queue_depth` is an integer that specifies the depth of the input queue for\
    \ the component. This is the number of messages that can be buffered in the queue\
    \ before the component will start to block. By default, the queue depth is 100.\n\
    \n\n##### num_instances\n\nThe `num_instances` is an integer that specifies the\
    \ number of instances of the component to run. This is the number of threads that\
    \ will be started to process messages from the input queue. By default, the number\
    \ of instances is 1.\n\n#### Built-in components\n\nThe AI Event Connector comes\
    \ with a number of built-in components that can be used to process messages. For\
    \ a list of all built-in components, see the [Components](components/index.md)\
    \ documentation.\n\n### Expression Syntax\n\nThe `source_expression` and `dest_expression`\
    \ values in the configuration file use a simple expression syntax to reference\
    \ values in the input message and to store values in the output message. The format\
    \ of the expression is:\n\n`<data_type>[.<qualifier>][:<index>]`\n\nWhere:\n\n\
    - `data_type`: <string> - The type of data to reference. This can be one of the\
    \ following:\n  - `input`: The input message. It supports the qualifiers:\n  \
    \  - `payload`: The payload of the input message\n    - `topic`: The topic of\
    \ the input message\n    - `topic_levels`: A list of the levels of the topic of\
    \ the input message\n    - `user_properties`: The user properties of the input\
    \ message\n  - `user_data`: The user data object. The qualifier is required to\
    \ specify the name of the user data object\n  - `static`: A static value (e.g.\
    \ `static:my_value`)\n  - `template`: A template (see more below)\n  - `previous`:\
    \ The output from the previous component in the flow. This could be of any type\
    \ depending on the previous component\n\n- `qualifier`: <string> - The qualifier\
    \ to use to reference the data. This is specific to the `data_type` and is optional.\
    \ If not specified, the entire data type will be used.\n\n- `index`: <string|int>\
    \ - Where to get the data in the data type. This is optional and is specific to\
    \ the `data_type`. For templates, it is the template. For other data types, it\
    \ is a dot separated string or an integer index. The index will be split on dots\
    \ and used to traverse the data type. If it is an integer, it will be used as\
    \ an index into the data type. If it is a string, it will be used as a key to\
    \ get the value from the data type.\n\nHere are some examples of expressions:\n\
    \n- `input.payload:my_key` - Get the value of `my_key` from the input payload\n\
    - `user_data.my_obj:my_key` - Get the value of `my_key` from the `my_obj` object\
    \ in the user data\n- `static:my_value` - Use the static value `my_value`\n- `user_data:my_obj2:my_list.2.my_key`\
    \ - Get the value of `my_key` from the 3rd item in the `my_list` list in the `my_obj2`\
    \ object in the user data\n\nWhen using expressions for destination expressions,\
    \ lists and objects will be created as needed. If the destination expression is\
    \ a list index, the list will be extended to the index if it is not long enough.\
    \ If the destination expression is an object key, the object will be created if\
    \ it does not exist.\n\n#### Templates\n\nThe `template` data type is a special\
    \ data type that allows you to use a template to create a value. The template\
    \ is a string that can contain expressions to reference values in the input message.\
    \ The format of the template is:\n\n`text text text {{template_expression}} text\
    \ text text`\n\nWhere:\n\n- `{{template_expression}}` - An expression to reference\
    \ values in the input message. It has the format:\n\n  `<encoding>://<source_expression>`\n\
    \n  Where:\n\n  - `encoding`: <string> - The encoding/formatting to use to print\
    \ out the value. This can be one of the following:\n    - `base64`: Use base64\
    \ encoding\n    - `json`: Use json format\n    - `yaml`: Use yaml format\n   \
    \ - `text`: Use string format\n    - `datauri:<mime_type>`: Use data uri encoding\
    \ with the specified mime type\n\n  - `source_expression`: <string> - An expression\
    \ to reference values in the input message. This has the same format as the `source_expression`\
    \ in the configuration file described above.\n\nHere is an example of a template:\n\
    \n```yaml\n  input_transforms:\n    - type: copy\n      source_expression: |\n\
    \        template:Write me a dry joke about:\n        {{text://input.payload}}\n\
    \        Write the joke in the voice of {{text://input.user_properties:comedian}}\n\
    \      dest_expression: user_data.llm_input:messages.0.content\n    - type: copy\n\
    \      source_value: user\n      dest_expression: user_data.llm_input:messages.0.role\n\
    ```\n\nIn this example, the `source_expression` for the first transform is a template\
    \ that uses the `text` encoding to create a string. \n\n</markdown_documentation>\n\
    Here is an example configuration: \nTake special care to ensure that the data\
    \ format is correct as it moves component to component. input_transforms will\
    \ likely need to be created to ensure that the data is in the correct format for\
    \ each component. \nNow, you will have to ask the user for the input_schema, queue,\
    \ or topic, and the desired output_schema and topic. \n", "system_prompt": "You\
    \ are an assistant who will help users create a new configuration for the Solace\
    \ AI Event Connector. The connector is a tool that allows users to create flows\
    \ that process messages from a Solace event broker, generally to help interface\
    \ with AI based services. A typical flow will start with a message from the broker,\
    \ pass through a series of components and transforms, and then send the message\
    \ back to the broker. The components and transforms are user-configurable and\
    \ can be used to manipulate the message in various ways. The user will have to\
    \ provide the message input_schema, queue, or topic, and the desired output_schema\
    \ and topic. Your job is to to create an initial configuration for the user. \n\
    Make sure you use ${ENV_VARS} for any sensitive information. \nYour interaction\
    \ with the user will via a chat interface. Before you generate the YAML configuration,\
    \ you will have to ask the user for the input_schema, queue, or topic, and the\
    \ desired output_schema and topic. \nYou can ask as many questions as you need\
    \ to get the information you need. Try to make the conversation flow naturally\
    \ and confirm the user's input if there is any ambiguity - for example, if they\
    \ input the schema in a mixed JSON/YAML/pseudo structure, print it back out for\
    \ them in a clean YAML format and get confirmation that it is correct\n"}
