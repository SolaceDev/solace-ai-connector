<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="1" failures="63" skipped="0" tests="117" time="16.655" timestamp="2024-10-29T15:30:14.297804-04:00" hostname="ArtMorozov.local"><testcase classname="" name="tests.test_acks" time="0.000"><error message="collection failure">../../Library/Application Support/hatch/env/virtual/solace-ai-connector/o_vSMEsS/hatch-test.py3.9/lib/python3.9/site-packages/_pytest/python.py:493: in importtestmodule
    mod = import_path(
../../Library/Application Support/hatch/env/virtual/solace-ai-connector/o_vSMEsS/hatch-test.py3.9/lib/python3.9/site-packages/_pytest/pathlib.py:582: in import_path
    importlib.import_module(module_name)
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1030: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1007: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:986: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:680: in _load_unlocked
    ???
../../Library/Application Support/hatch/env/virtual/solace-ai-connector/o_vSMEsS/hatch-test.py3.9/lib/python3.9/site-packages/_pytest/assertion/rewrite.py:184: in exec_module
    exec(co, module.__dict__)
tests/test_acks.py:8: in &lt;module&gt;
    from solace_ai_connector.test_utils.utils_for_test_files import (  # pylint: disable=wrong-import-position
src/solace_ai_connector/test_utils/utils_for_test_files.py:8: in &lt;module&gt;
    from solace_ai_connector.solace_ai_connector import SolaceAiConnector
src/solace_ai_connector/solace_ai_connector.py:10: in &lt;module&gt;
    from .flow.flow import Flow
src/solace_ai_connector/flow/flow.py:6: in &lt;module&gt;
    from ..components.component_base import ComponentBase
src/solace_ai_connector/components/__init__.py:28: in &lt;module&gt;
    from .general.langchain import (
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax</error></testcase><testcase classname="tests.test_aggregate" name="test_aggregate_by_time" time="0.008"><failure message="ImportError: Module load error for solace_ai_connector.components.aggregate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'aggregate', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'aggregate'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_aggregate_by_time():
        """Test the aggregate component by time"""
        TIMEOUT_MS = 700
        config_yaml = f"""
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: aggregate
            component_module: aggregate
            component_config:
              max_items: 10
              max_time_ms: {TIMEOUT_MS}
            input_selection:
              source_expression: input.payload
    """
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_aggregate.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.aggregate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_aggregate" name="test_both_items_and_time" time="0.043"><failure message="ImportError: Module load error for solace_ai_connector.components.aggregate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'aggregate', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'aggregate'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_both_items_and_time():
        """Test the aggregate component by items"""
        MAX_TIME_MS = 1000
        config_yaml = f"""
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: aggregate
            component_module: aggregate
            component_config:
              max_items: 3
              max_time_ms: {MAX_TIME_MS}
            input_selection:
              source_expression: input.payload
    """
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_aggregate.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.aggregate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_config_file" name="test_component_missing_info_attribute" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.utils: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'utils', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'utils', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'utils'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'utils', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_component_missing_info_attribute():
        """Test that the program exits if the component module is missing the info attribute"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: delay1
            component_module: utils
    """
        with pytest.raises(ValueError) as e:
&gt;           create_connector(
                config_yaml,
            )

tests/test_config_file.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'utils', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.utils: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_config_file" name="test_static_import_and_object_config" time="0.001"><failure message="AttributeError: module 'solace_ai_connector' has no attribute 'components'">def test_static_import_and_object_config():
        """Test that we can statically import a module and pass an object for the config"""
    
        config = {
            "log": {"log_file_level": "DEBUG", "log_file": "solace_ai_connector.log"},
            "flows": [
                {
                    "name": "test_flow",
                    "components": [
                        {
                            "component_name": "delay1",
&gt;                           "component_module": solace_ai_connector.components.general.pass_through,
                            "component_config": {"delay": 0.1},
                            "input_selection": {"source_expression": "input.payload"},
                        }
                    ],
                }
            ],
        }
E       AttributeError: module 'solace_ai_connector' has no attribute 'components'

tests/test_config_file.py:164: AttributeError</failure></testcase><testcase classname="tests.test_invoke" name="test_resolve_config_values[test2]" time="0.003"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

test = {'expected': {'a': 1, 'b': 2, 'c': {'d': 3, 'e': 3}}, 'input': {'a': 1, 'b': 2, 'c': {'d': 3, 'e': {'invoke': {'function': 'add', 'module': 'invoke_functions', 'params': {'x': 1, 'y': 2}}}}}}

    @pytest.mark.parametrize("test", tests)
    def test_resolve_config_values(test):
&gt;       assert resolve_config_values(test["input"]) == test["expected"]

tests/test_invoke.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_filter" name="test_simple_filter" time="0.007"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_simple_filter():
        """Test the filter component with a simple expression"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: message_filter
            component_module: message_filter
            component_config:
              filter_expression:
                invoke:
                  module: invoke_functions
                  function: equal
                  params:
                    positional:
                      - evaluate_expression(input.payload:my_list.1)
                      - 2
    """
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_filter.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_flows" name="test_on_flow_creation_event" time="0.012"><failure message="ImportError: Module load error for solace_ai_connector.components.delay: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'delay', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'delay', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'delay'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'delay', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_on_flow_creation_event():
        """Test that the on_flow_creation event is called when a flow is created"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: delay1
            component_module: delay
            input_selection:
              source_expression: input.payload:text
      - name: test_flow2
        components:
          - component_name: delay2
            component_module: delay
            input_selection:
              source_expression: input.payload:text
    """
        event_handler_called = False
        flows = []
    
        def event_handler(created_flows):
            nonlocal event_handler_called
            nonlocal flows
            event_handler_called = True
            flows = created_flows
    
        # Create the connector
&gt;       connector = create_connector(
            config_yaml, event_handlers={"on_flow_creation": event_handler}
        )

tests/test_flows.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'delay', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.delay: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_resolve_config_values[test0]" time="0.001" /><testcase classname="tests.test_filter" name="test_filter_with_multi_stage_data" time="0.008"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_filter_with_multi_stage_data():
        """Test the filter component with a previous stage passing on data and the filter
        input_transforms copying that data into a user_data area"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: user_processor
            component_module: user_processor
            component_config:
              component_processing:
                invoke:
                  module: invoke_functions
                  function: add
                  params:
                    positional:
                      - 5
                      - 6
          - component_name: message_filter
            component_module: message_filter
            component_config:
              filter_expression:
                invoke:
                  module: invoke_functions
                  function: not_equal
                  params:
                    positional:
                      - 1
                      - 2
            input_transforms:
              - type: copy
                source_expression: previous
                dest_expression: user_data.output
          - component_name: pass_through
            component_module: pass_through
    
    
    """
&gt;       connector, flows = create_test_flows(config_yaml, queue_timeout=1)

tests/test_filter.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_config_file" name="test_no_component_name" time="0.005" /><testcase classname="tests.test_config_file" name="test_no_flow_components" time="0.002" /><testcase classname="tests.test_invoke" name="test_resolve_config_values[test1]" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

test = {'expected': {'a': 1, 'b': 2, 'c': 3}, 'input': {'a': 1, 'b': 2, 'c': {'invoke': {'function': 'add', 'module': 'invoke_functions', 'params': {'x': 1, 'y': 2}}}}}

    @pytest.mark.parametrize("test", tests)
    def test_resolve_config_values(test):
&gt;       assert resolve_config_values(test["input"]) == test["expected"]

tests/test_invoke.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_config_file" name="test_no_component_module" time="0.002" /><testcase classname="tests.test_invoke" name="test_resolve_config_values_missing_module" time="0.003"><failure message="AssertionError: Regex pattern did not match.&#10; Regex: &quot;Module 'missing_module' not found&quot;&#10; Input: 'Module load error for solace_ai_connector.components.missing_module: invalid syntax (langchain_vector_store_embedding_index.py, line 142)'">module = 'missing_module', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'missing_module', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'missing_module'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'missing_module', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_resolve_config_values_missing_module():
        with pytest.raises(ImportError, match="Module 'missing_module' not found"):
&gt;           resolve_config_values(
                {
                    "a": {
                        "invoke": {
                            "module": "missing_module",
                            "function": "add",
                            "params": {
                                "x": 1,
                                "y": 2,
                            },
                        },
                    },
                }
            )

tests/test_invoke.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'missing_module', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.missing_module: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError

During handling of the above exception, another exception occurred:

    def test_resolve_config_values_missing_module():
        with pytest.raises(ImportError, match="Module 'missing_module' not found"):
&gt;           resolve_config_values(
                {
                    "a": {
                        "invoke": {
                            "module": "missing_module",
                            "function": "add",
                            "params": {
                                "x": 1,
                                "y": 2,
                            },
                        },
                    },
                }
            )
E           AssertionError: Regex pattern did not match.
E            Regex: "Module 'missing_module' not found"
E            Input: 'Module load error for solace_ai_connector.components.missing_module: invalid syntax (langchain_vector_store_embedding_index.py, line 142)'

tests/test_invoke.py:364: AssertionError</failure></testcase><testcase classname="tests.test_config_file" name="test_no_flows" time="0.004" /><testcase classname="tests.test_config_file" name="test_flow_components_not_list" time="0.005" /><testcase classname="tests.test_invoke" name="test_resolve_config_values_missing_attribute" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_resolve_config_values_missing_attribute():
        with pytest.raises(
            AttributeError,
            match="module 'solace_ai_connector.common.invoke_functions' has no attribute 'missing'",
        ):
&gt;           resolve_config_values(
                {
                    "a": {
                        "invoke": {
                            "module": "invoke_functions",
                            "attribute": "missing",
                        },
                    },
                }
            )

tests/test_invoke.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_config_file" name="test_no_flow_name" time="0.010" /><testcase classname="tests.test_config_file" name="test_bad_module" time="0.011"><failure message="assert 'Module load ...py, line 142)' == &quot;Module 'not_...le' not found&quot;&#10;  &#10;  - Module 'not_a_module' not found&#10;  + Module load error for solace_ai_connector.components.not_a_module: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'not_a_module', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'not_a_module', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'not_a_module'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'not_a_module', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_bad_module():
        """Test that the program exits if the component module is not found"""
        try:
            config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: delay1
            component_module: not_a_module
    """
            sac = SolaceAiConnector(
                yaml.safe_load(config_yaml),
            )
&gt;           sac.run()

tests/test_config_file.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'not_a_module', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.not_a_module: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError

During handling of the above exception, another exception occurred:

    def test_bad_module():
        """Test that the program exits if the component module is not found"""
        try:
            config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: delay1
            component_module: not_a_module
    """
            sac = SolaceAiConnector(
                yaml.safe_load(config_yaml),
            )
            sac.run()
        except Exception as e:
&gt;           assert str(e) == "Module 'not_a_module' not found"
E           assert 'Module load ...py, line 142)' == "Module 'not_...le' not found"
E             
E             - Module 'not_a_module' not found
E             + Module load error for solace_ai_connector.components.not_a_module: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

tests/test_config_file.py:211: AssertionError</failure></testcase><testcase classname="tests.test_invoke" name="test_resolve_config_values_global_function" time="0.001" /><testcase classname="tests.test_invoke" name="test_resolve_config_values_missing_global_function" time="0.001" /><testcase classname="tests.test_invoke" name="test_invoke_params_bad_keyword" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_params_bad_keyword():
        """Verify that an error is raised if the keyword parameter is not a dict"""
        with pytest.raises(ValueError, match="keyword must be a dict"):
&gt;           resolve_config_values(
                {
                    "a": {
                        "invoke": {
                            "module": "invoke_functions",
                            "function": "add",
                            "params": {
                                "keyword": 1,
                            },
                        },
                    },
                }
            )

tests/test_invoke.py:503: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_resolve_config_values_missing_object" time="0.001" /><testcase classname="tests.test_invoke" name="test_invoke_params_with_positional" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_params_with_positional():
        """Verify that positional parameters work as expected"""
&gt;       assert resolve_config_values(
            {
                "a": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "_test_positional_args",
                        "params": {
                            "positional": [1, 2],
                        },
                    },
                },
            }
        ) == {"a": (1, 2)}

tests/test_invoke.py:538: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_resolve_config_values[test4]" time="0.005"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

test = {'expected': {'a': 1, 'b': 2, 'c': [3, {'d': 4, 'e': 3}]}, 'input': {'a': 1, 'b': 2, 'c': [3, {'d': 4, 'e': {'invoke': {'function': 'add', 'module': 'invoke_functions', 'params': {...}}}}]}}

    @pytest.mark.parametrize("test", tests)
    def test_resolve_config_values(test):
&gt;       assert resolve_config_values(test["input"]) == test["expected"]

tests/test_invoke.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_filter" name="test_missing_item_filter" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_missing_item_filter():
        """Test the filter component with data items that are missing"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: message_filter
            component_module: message_filter
            component_config:
              filter_expression:
                invoke:
                  module: invoke_functions
                  function: not_equal
                  params:
                    positional:
                      - evaluate_expression(input.payload:my_list)
                      - null
    """
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_filter.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_error_flows" name="test_basic_error_flow" time="0.015"><failure message="ImportError: Module load error for solace_ai_connector.components.fail: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'fail', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'fail', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'fail'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'fail', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_basic_error_flow():
        """Test the basic error flow"""
        # Create a simple configuration
        config_yaml = """
    instance_name: test_instance
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      # This will fail with the specified error
      - name: fail_flow
        components:
          - component_name: fail
            component_module: fail
            component_config:
              error_message: This is an error message
              exception_type: ValueError
    
      # This will handle the error
      - name: error_flow
        components:
          - component_name: error_input
            component_module: error_input
          - component_name: pass_through
            component_module: pass_through
            input_selection:
              source_expression: previous:error.text
    """
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_error_flows.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'fail', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.fail: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_resolve_config_values[test3]" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

test = {'expected': {'a': 1, 'b': 2, 'c': [3, 3]}, 'input': {'a': 1, 'b': 2, 'c': [3, {'invoke': {'function': 'add', 'module': 'invoke_functions', 'params': {'x': 1, 'y': 2}}}]}}

    @pytest.mark.parametrize("test", tests)
    def test_resolve_config_values(test):
&gt;       assert resolve_config_values(test["input"]) == test["expected"]

tests/test_invoke.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_flows" name="test_multiple_flow_instances" time="0.012"><failure message="ImportError: Module load error for solace_ai_connector.components.delay: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'delay', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'delay', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'delay'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'delay', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_multiple_flow_instances():
        """Test that multiple flow instances work"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        num_instances: 4
        components:
          - component_name: delay1
            component_module: delay
            input_selection:
              source_expression: input.payload:text
    """
        # Create the connector
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_flows.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'delay', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.delay: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_config_file" name="test_no_config_file" time="0.002" /><testcase classname="tests.test_invoke" name="test_invoke_with_evaluate_expression_keyword" time="0.006"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_evaluate_expression_keyword():
        """Verify that the evaluate expression is evaluated"""
&gt;       config = resolve_config_values(
            {
                "source_value": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "_test_keyword_args",
                        "params": {
                            "keyword": {
                                "x": "evaluate_expression(input.payload:my_obj.val1)",
                                "y": "evaluate_expression(input.payload:my_obj.val2)",
                            },
                        },
                    },
                },
            }
        )

tests/test_invoke.py:701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_aggregate" name="test_aggregate_by_items" time="0.008"><failure message="ImportError: Module load error for solace_ai_connector.components.aggregate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'aggregate', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'aggregate'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_aggregate_by_items():
        """Test the aggregate component by items"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: aggregate
            component_module: aggregate
            component_config:
              max_items: 3
              max_time_ms: 1000
            input_selection:
              source_expression: input.payload
    """
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_aggregate.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'aggregate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.aggregate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_params_with_both_positional_and_keyword" time="0.006"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_params_with_both_positional_and_keyword():
        """Verify that both positional and keyword parameters work as expected"""
&gt;       assert resolve_config_values(
            {
                "a": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "_test_positional_and_keyword_args",
                        "params": {
                            "positional": [1, 2],
                            "keyword": {"x": 1, "y": 2},
                        },
                    },
                },
            }
        ) == {"a": ((1, 2), {"x": 1, "y": 2})}

tests/test_invoke.py:520: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_filter" name="test_filter_with_multi_stage_data_with_timer_input" time="0.023"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_filter_with_multi_stage_data_with_timer_input():
        """Test the filter component with a previous stage passing on data and the filter
        input_transforms copying that data into a user_data area - this time with a timer causing the message to be sent
        """
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    trace:
      trace_file: solace_ai_connector.trace
    flows:
      - name: test_flow
        components:
          - component_name: timer_input
            component_module: timer_input
            component_config:
              interval_ms: 500
              skip_messages_if_behind: false
          - component_name: user_processor
            component_module: user_processor
            component_config:
              component_processing:
                invoke:
                  module: invoke_functions
                  function: add
                  params:
                    positional:
                      - 5
                      - 6
          - component_name: message_filter
            component_module: message_filter
            component_config:
              filter_expression:
                invoke:
                  module: invoke_functions
                  function: not_equal
                  params:
                    positional:
                      - 1
                      - 2
            input_transforms:
              - type: copy
                source_expression: previous
                dest_expression: user_data.output
          - component_name: pass_through
            component_module: pass_through
    
    
    """
&gt;       connector, flows = create_test_flows(config_yaml, queue_timeout=3)

tests/test_filter.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_call_function_no_params" time="0.002" /><testcase classname="tests.test_invoke" name="test_invoke_params_bad_positional" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_params_bad_positional():
        """Verify that an error is raised if the positional parameter is not a list"""
        with pytest.raises(ValueError, match="positional must be a list"):
&gt;           resolve_config_values(
                {
                    "a": {
                        "invoke": {
                            "module": "invoke_functions",
                            "function": "add",
                            "params": {
                                "positional": 1,
                            },
                        },
                    },
                }
            )

tests/test_invoke.py:485: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_resolve_config_values_missing_function" time="0.006"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_resolve_config_values_missing_function():
        with pytest.raises(
            AttributeError,
            match="module 'solace_ai_connector.common.invoke_functions' has no attribute 'missing'",
        ):
&gt;           resolve_config_values(
                {
                    "a": {
                        "invoke": {
                            "module": "invoke_functions",
                            "function": "missing",
                            "params": {
                                "x": 1,
                                "y": 2,
                            },
                        },
                    },
                }
            )

tests/test_invoke.py:386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_params_with_keyword" time="0.005"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_params_with_keyword():
        """Verify that keyword parameters work as expected"""
&gt;       assert resolve_config_values(
            {
                "a": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "_test_keyword_args",
                        "params": {
                            "keyword": {"x": 1, "y": 2},
                        },
                    },
                },
            }
        ) == {"a": {"x": 1, "y": 2}}

tests/test_invoke.py:555: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_resolve_config_values[test5]" time="0.004"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

test = {'expected': {'a': 1, 'b': 2, 'c': {'add': 3, 'and_op': False, 'divide': 0.5, 'equal': False, ...}}, 'input': {'a': 1,...]}}}, 'equal': {'invoke': {'function': 'equal', 'module': 'invoke_functions', 'params': {'positional': [...]}}}, ...}}}

    @pytest.mark.parametrize("test", tests)
    def test_resolve_config_values(test):
&gt;       assert resolve_config_values(test["input"]) == test["expected"]

tests/test_invoke.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_with_source_expression_cast_to_bool" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_source_expression_cast_to_bool():
        """Verify that the source expression is evaluated"""
&gt;       config = resolve_config_values(
            {
                "source_expression": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "and_op",
                        "params": {
                            "positional": [
                                "evaluate_expression(input.payload:my_obj.val1 , bool )",
                                True,
                            ],
                        },
                    },
                },
            }
        )

tests/test_invoke.py:655: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_with_evaluate_expression_cast_to_int" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_evaluate_expression_cast_to_int():
        """Verify that the evaluate expression is evaluated"""
&gt;       config = resolve_config_values(
            {
                "source_expression": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "add",
                        "params": {
                            "positional": [
                                "evaluate_expression(input.payload:my_obj.val1, int )",
                                2,
                            ],
                        },
                    },
                },
            }
        )

tests/test_invoke.py:609: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_with_source_expression_no_evaluate_expression" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_source_expression_no_evaluate_expression():
        """Verify that the evaluated expression is evaluated"""
        with pytest.raises(
            ValueError, match=r"evaluate_expression\(\) must contain an expression"
        ):
&gt;           resolve_config_values(
                {
                    "source_expression": {
                        "invoke": {
                            "module": "invoke_functions",
                            "function": "add",
                            "params": {
                                "positional": [
                                    "evaluate_expression()",
                                    2,
                                ],
                            },
                        },
                    },
                }
            )

tests/test_invoke.py:812: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_import_os_module" time="0.001" /><testcase classname="tests.test_invoke" name="test_invoke_with_evaluate_expression_simple" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_evaluate_expression_simple():
        """Verify that the evaluate expression is evaluated"""
&gt;       config = resolve_config_values(
            {
                "source_expression": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "add",
                        "params": {
                            "positional": [
                                "evaluate_expression(input.payload:my_obj.val1)",
                                "evaluate_expression(input.payload:my_obj.val2)",
                            ],
                        },
                    },
                },
            }
        )

tests/test_invoke.py:586: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_with_evaluate_expression_missing" time="0.009"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_evaluate_expression_missing():
        """Verify that the evaluate expression is evaluated"""
&gt;       config = resolve_config_values(
            {
                "source_expression": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "add",
                        "params": {
                            "positional": [
                                "evaluate_expression(input.payload:my_obj.val1)",
                                "evaluate_expression(input.payload:my_obj.val2)",
                            ],
                        },
                    },
                },
            }
        )

tests/test_invoke.py:784: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_with_evaluate_expression_with_real_flow" time="0.013"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_evaluate_expression_with_real_flow():
        """Verify that the evaluate expression is evaluated properly in transforms and input_selection"""
        config_yaml = """
    instance_name: test_instance
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: copy
                source_value:
                  invoke:
                    module: invoke_functions
                    function: add
                    params:
                      positional:
                        - evaluate_expression(input.payload:my_obj.val1.1)
                        - 2
                dest_expression: user_data.temp:my_val
            input_selection:
              source_expression:
                invoke:
                  module: invoke_functions
                  function: add
                  params:
                    positional:
                      - evaluate_expression(input.payload:my_obj.obj2)
                      - " test"
    """
        message = Message(payload={"my_obj": {"val1": [1, 2, 3], "obj2": "Hello, World!"}})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_invoke.py:864: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_with_evaluate_expression_complex" time="0.009"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_evaluate_expression_complex():
        """Verify that the evaluate expression is evaluated"""
&gt;       config = resolve_config_values(
            {
                "source_expression": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "_test_positional_and_keyword_args",
                        "params": {
                            "positional": [
                                "evaluate_expression(input.payload:my_obj.val1)",
                                {
                                    "invoke": {
                                        "module": "invoke_functions",
                                        "function": "add",
                                        "params": {
                                            "positional": [
                                                "evaluate_expression(input.payload:my_obj.val2)",
                                                {
                                                    "invoke": {
                                                        "module": "invoke_functions",
                                                        "function": "multiply",
                                                        "params": {
                                                            "positional": [
                                                                "evaluate_expression(input.payload:my_obj.val2)",
                                                                "evaluate_expression(input.payload:my_obj.val2)",
                                                            ],
                                                        },
                                                    },
                                                },
                                            ],
                                        },
                                    },
                                },
                            ],
                            "keyword": {
                                "x": "evaluate_expression(input.payload:my_obj.val1)",
                                "y": {
                                    "invoke": {
                                        "module": "invoke_functions",
                                        "function": "subtract",
                                        "params": {
                                            "positional": [
                                                "evaluate_expression(input.payload:my_obj.val2)",
                                                "evaluate_expression(input.payload:my_obj.val3)",
                                            ],
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            }
        )

tests/test_invoke.py:724: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:86: in resolve_config_values
    resolve_config_values(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:86: in resolve_config_values
    resolve_config_values(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_reduce_transform_make_list" time="0.008"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_reduce_transform_make_list():
        """Test the reduce transform with an accumulator"""
        config_yaml = """
    instance_name: test_instance
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: reduce
                source_list_expression: input.payload:my_list
                initial_value:
                  invoke:
                    module: invoke_functions
                    function: empty_list
                accumulator_function:
                  invoke:
                    module: invoke_functions
                    function: append
                    params:
                      positional:
                        - evaluate_expression(keyword_args:accumulated_value)
                        - evaluate_expression(keyword_args:current_value)
                dest_expression: user_data.temp:my_val
            input_selection:
              source_expression: user_data.temp:my_val
       """
        message = Message(payload={"my_list": [1, 2, 3, 4, 5]})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_invoke.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_map_transform_add_2" time="0.007"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_map_transform_add_2():
        """Test the map transform with a processing function"""
        config_yaml = """
    instance_name: test_instance
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: map
                source_list_expression: input.payload:my_list
                processing_function:
                  invoke:
                    module: invoke_functions
                    function: add
                    params:
                      positional:
                        - evaluate_expression(keyword_args:current_value)
                        - 2
                dest_list_expression: user_data.temp:new_list
            input_selection:
              source_expression: user_data.temp:new_list
       """
        message = Message(payload={"my_list": [1, 2, 3, 4, 5]})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_invoke.py:1002: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_filter_transform_greater_than_2" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_filter_transform_greater_than_2():
        """Test the filter transform with a filter function checking for values &gt; 2"""
        config_yaml = """
    instance_name: test_instance
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: filter
                source_list_expression: input.payload:my_list
                filter_function:
                  invoke:
                    module: invoke_functions
                    function: greater_than
                    params:
                      positional:
                        - evaluate_expression(keyword_args:current_value)
                        - 2
                dest_list_expression: user_data.temp:new_list
            input_selection:
              source_expression: user_data.temp:new_list
       """
        message = Message(payload={"my_list": [1, 2, 3, 4, 5]})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_invoke.py:1036: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_reduce_transform_accumulator" time="0.013"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_reduce_transform_accumulator():
        """Test the reduce transform with an accumulator"""
        config_yaml = """
    instance_name: test_instance
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: reduce
                source_list_expression: input.payload:my_list
                initial_value: 0
                accumulator_function:
                    invoke:
                        module: invoke_functions
                        function: add
                        params:
                            positional:
                                - evaluate_expression(keyword_args:accumulated_value)
                                - evaluate_expression(keyword_args:current_value)
                dest_expression: user_data.temp:my_val
            input_selection:
              source_expression: user_data.temp:my_val
    """
        message = Message(payload={"my_list": [1, 2, 3, 4, 5]})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_invoke.py:930: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_with_uuid_generator" time="0.004"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_uuid_generator():
        """Verify that the uuid invoke_function returns an ID"""
&gt;       response = resolve_config_values(
            {
                "a": {
                    "invoke": {"module": "invoke_functions", "function": "uuid"},
                },
            }
        )

tests/test_invoke.py:1084: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_invoke_with_evaluate_expression_cast_to_float" time="0.003"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_evaluate_expression_cast_to_float():
        """Verify that the evaluate expression is evaluated"""
&gt;       config = resolve_config_values(
            {
                "source_expression": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "add",
                        "params": {
                            "positional": [
                                "evaluate_expression(input.payload:my_obj.val1, float )",
                                2,
                            ],
                        },
                    },
                },
            }
        )

tests/test_invoke.py:632: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_invoke" name="test_filter_transform_sub_field_greater_than_2" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_filter_transform_sub_field_greater_than_2():
        """Test the filter transform with a filter function checking for values &gt; 2"""
        config_yaml = """
    instance_name: test_instance
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: filter
                source_list_expression: input.payload:my_list
                filter_function:
                  invoke:
                    module: invoke_functions
                    function: greater_than
                    params:
                      positional:
                        - evaluate_expression(keyword_args:current_value.my_val)
                        - 2
                dest_list_expression: user_data.temp:new_list
            input_selection:
              source_expression: user_data.temp:new_list
       """
        message = Message(
            payload={
                "my_list": [{"my_val": 1}, {"my_val": 2}, {"my_val": 3}, {"my_val": 4}]
            }
        )
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_invoke.py:1074: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:71: in create_connector
    connector = SolaceAiConnector(
src/solace_ai_connector/solace_ai_connector.py:30: in __init__
    resolve_config_values(self.config)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:82: in resolve_config_values
    config[index] = resolve_config_values(item, allow_source_expression)
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_get_data_simple_payload" time="0.001" /><testcase classname="tests.test_invoke" name="test_invoke_with_evaluate_expression_cast_to_str" time="0.002"><failure message="ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'invoke_functions', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'invoke_functions'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_invoke_with_evaluate_expression_cast_to_str():
        """Verify that the evaluate expression is evaluated"""
&gt;       config = resolve_config_values(
            {
                "source_expression": {
                    "invoke": {
                        "module": "invoke_functions",
                        "function": "add",
                        "params": {
                            "positional": [
                                "evaluate_expression(input.payload:my_obj.val1,str)",
                                "2",
                            ],
                        },
                    },
                },
            }
        )

tests/test_invoke.py:678: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/common/utils.py:93: in resolve_config_values
    config[key] = resolve_config_values(
src/solace_ai_connector/common/utils.py:87: in resolve_config_values
    config = invoke_config(config["invoke"], allow_source_expression)
src/solace_ai_connector/common/utils.py:182: in invoke_config
    obj = import_module(module, base_path=path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'invoke_functions', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.invoke_functions: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_get_data_invalid_data_name" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_template" time="0.002" /><testcase classname="tests.test_iterate" name="test_small_list" time="0.020"><failure message="ImportError: Module load error for solace_ai_connector.components.iterate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'iterate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'iterate', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'iterate'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'iterate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_small_list():
        """Test the iterate component with a small list"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: iterate
            component_module: iterate
            input_selection:
              source_expression: input.payload:my_list
    """
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_iterate.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'iterate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.iterate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_template_json" time="0.002" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_template_datauri" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_base64" time="0.002" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_previous" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_static_value" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_dangling_colon" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_complex_payload" time="0.003" /><testcase classname="tests.test_message_get_set_data" name="test_index_into_list" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_deeply_nested_payload" time="0.002" /><testcase classname="tests.test_message_get_set_data" name="test_get_topic_levels" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_index_into_list_out_of_bounds" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_list" time="0.001" /><testcase classname="tests.test_iterate" name="test_large_list" time="0.013"><failure message="ImportError: Module load error for solace_ai_connector.components.iterate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'iterate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'iterate', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'iterate'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'iterate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_large_list():
        """Test the iterate component with a large list"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: iterate
            component_module: iterate
            input_selection:
              source_expression: input.payload:my_list
    """
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_iterate.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'iterate', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.iterate: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_simple" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_dict" time="0.002" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_overwrite_entire_object" time="0.002" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_overwrite_existing_property" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_create_new_list" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_overwrite_scalar" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_overwrite_list" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_input_payload" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_input_topic" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_invalid_expression" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_input_user_properties" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_user_properties" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_get_set_payload" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_get_set_topic" time="0.001" /><testcase classname="tests.test_message_get_set_data" name="test_get_set_previous" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_list_middle_success" time="0.000" /><testcase classname="tests.test_request_response_controller" name="test_request_response_flow_controller_streaming" time="0.006"><failure message="ImportError: Module load error for solace_ai_connector.components.handler_callback: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'handler_callback', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'handler_callback'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_request_response_flow_controller_streaming():
        """Test streaming functionality of the RequestResponseFlowController"""
    
        def test_invoke_handler(component, message, data):
            result = []
            for message, last_message in component.do_broker_request_response(
                message, stream=True, streaming_complete_expression="input.payload:last"
            ):
                payload = message.get_data("input.payload")
                result.append(payload)
                if last_message:
                    assert payload == {"text": "Chunk3", "last": True}
    
            assert result == [
                {"text": "Chunk1", "last": False},
                {"text": "Chunk2", "last": False},
                {"text": "Chunk3", "last": True},
            ]
    
            return "Pass"
    
        config = {
            "flows": [
                {
                    "name": "test_flow",
                    "components": [
                        {
                            "component_name": "requester",
                            "component_module": "handler_callback",
                            "component_config": {
                                "invoke_handler": test_invoke_handler,
                            },
                            "broker_request_response": {
                                "enabled": True,
                                "broker_config": {
                                    "broker_type": "test_streaming",
                                    "broker_url": "test",
                                    "broker_username": "test",
                                    "broker_password": "test",
                                    "broker_vpn": "test",
                                    "payload_encoding": "utf-8",
                                    "payload_format": "json",
                                },
                                "request_expiry_ms": 500000,
                            },
                        }
                    ],
                },
            ]
        }
&gt;       connector, flows = create_test_flows(config)

tests/test_request_response_controller.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.handler_callback: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_get_set_user_properties" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_set_data_list_middle_failure" time="0.001" /><testcase classname="tests.test_request_response_controller" name="test_request_response_flow_controller_timeout" time="0.007"><failure message="ImportError: Module load error for solace_ai_connector.components.handler_callback: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'handler_callback', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'handler_callback'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_request_response_flow_controller_timeout():
        """Test timeout functionality of the RequestResponseFlowController"""
    
        def test_invoke_handler(component, message, data):
            # # Call the request_response_flow
            # data_iter = component.send_request_response_flow_message(
            #     "test_controller", message, {"test": "data"}
            # )
    
            # # This will timeout
            # try:
            #     for message, data, _last_message in data_iter():
            #         assert message.get_data("previous") == {"test": "data"}
            #         assert message.get_data("input.payload") == {"text": "Hello, World!"}
            # except TimeoutError:
            #     return "timeout"
            # return "done"
    
            # Do it the new way
            try:
                for message, _last_message in component.do_broker_request_response(
                    message, stream=True, streaming_complete_expression="input.payload:last"
                ):
                    pass
            except TimeoutError:
                return "Timeout"
            return "Fail"
    
        config = {
            "flows": [
                {
                    "name": "test_flow",
                    "components": [
                        {
                            "component_name": "requester",
                            "component_module": "handler_callback",
                            "component_config": {
                                "invoke_handler": test_invoke_handler,
                            },
                            "broker_request_response": {
                                "enabled": True,
                                "broker_config": {
                                    "broker_type": "test_streaming",
                                    "broker_url": "test",
                                    "broker_username": "test",
                                    "broker_password": "test",
                                    "broker_vpn": "test",
                                    "payload_encoding": "utf-8",
                                    "payload_format": "json",
                                },
                                "request_expiry_ms": 2000,
                            },
                        }
                    ],
                },
            ]
        }
&gt;       connector, flows = create_test_flows(config)

tests/test_request_response_controller.py:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.handler_callback: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_timer_input" name="test_basic_timer" time="0.013"><failure message="ImportError: Module load error for solace_ai_connector.components.timer_input: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'timer_input', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'timer_input'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_basic_timer():
        """Test the timer input component without a catchup timer"""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: timer_input
            component_module: timer_input
            component_config:
              interval_ms: 500
              skip_messages_if_behind: false
      - name: add_timestamp
        components:
          - component_name: add_timestamp
            component_module: pass_through
            input_transforms:
              - type: copy
                source_expression:
                  invoke:
                    module: time
                    function: time
                dest_expression: user_data.timestamp
            input_selection:
              source_expression: user_data.timestamp
    """
    
        start_time = time.time()
&gt;       connector, flows = create_test_flows(config_yaml)

tests/test_timer_input.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.timer_input: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_timer_input" name="test_with_no_skip_timer" time="0.009"><failure message="ImportError: Module load error for solace_ai_connector.components.timer_input: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'timer_input', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'timer_input'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_with_no_skip_timer():
        """Create a simple timer input component with a catchup timer."""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: timer_input
            component_module: timer_input
            component_config:
              interval_ms: 500
              skip_messages_if_behind: false
    """
    
&gt;       connector, flows = create_test_flows(config_yaml, queue_size=1)

tests/test_timer_input.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.timer_input: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_request_response_controller" name="test_request_response_flow_controller_basic" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.handler_callback: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'handler_callback', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'handler_callback'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_request_response_flow_controller_basic():
        """Test basic functionality of the RequestResponseFlowController"""
    
        def test_invoke_handler(component, message, _data):
            # Call the request_response
            message = component.do_broker_request_response(message)
            try:
                assert message.get_data("previous") == {
                    "payload": {"text": "Hello, World!"},
                    "topic": None,
                    "user_properties": {},
                }
            except AssertionError as e:
                return e
            return "Pass"
    
        config = {
            "flows": [
                {
                    "name": "test_flow",
                    "components": [
                        {
                            "component_name": "requester",
                            "component_module": "handler_callback",
                            "component_config": {
                                "invoke_handler": test_invoke_handler,
                            },
                            "broker_request_response": {
                                "enabled": True,
                                "broker_config": {
                                    "broker_type": "test",
                                    "broker_url": "test",
                                    "broker_username": "test",
                                    "broker_password": "test",
                                    "broker_vpn": "test",
                                    "payload_encoding": "utf-8",
                                    "payload_format": "json",
                                },
                                "request_expiry_ms": 500000,
                            },
                        }
                    ],
                },
            ]
        }
&gt;       connector, flows = create_test_flows(config)

tests/test_request_response_controller.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'handler_callback', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.handler_callback: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_get_data_long_topic" time="0.000" /><testcase classname="tests.test_transforms" name="test_transform_with_run_component_test" time="0.009"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_transform_with_run_component_test():
        """This test is actually testing the test infrastructure method: run_component_test"""
    
        def validation_func(output_data, output_message, _input_message):
            assert output_data[0] == "Hello, World!"
            assert output_message[0].get_data("user_data.temp") == {
                "payload": {"text": "Hello, World!", "greeting": "Static Greeting!"}
            }
    
&gt;       run_component_test(
            "pass_through",
            validation_func,
            input_data={"text": "Hello, World!"},
            input_transforms=[
                {
                    "type": "copy",
                    "source_expression": "input.payload",
                    "dest_expression": "user_data.temp:payload",
                },
                {
                    "type": "copy",
                    "source_value": "Static Greeting!",
                    "dest_expression": "user_data.temp:payload.greeting",
                },
            ],
            input_selection={"source_expression": "user_data.temp:payload.text"},
        )

tests/test_transforms.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:113: in run_component_test
    connector, flows = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_topic" time="0.002" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_invalid_payload_name" time="0.001" /><testcase classname="tests.test_transforms" name="test_basic_append_transform" time="0.012"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_basic_append_transform():
        """Test the basic append transform"""
        # Create a simple configuration
        config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: append
                source_expression: input.payload:one
                dest_expression: user_data.temp:my_list
              - type: append
                source_expression: input.payload:two
                dest_expression: user_data.temp:my_list
              - type: append
                source_expression: input.payload:three
                dest_expression: user_data.temp:my_list
            input_selection:
              source_expression: user_data.temp
    """
    
        message = Message(payload={"one": 1, "two": 2, "three": 3})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_transforms.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_overwrite_non_list_with_list" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_overwrite_non_list_with_list():
        """Test that a non-list value is overwritten by a list"""
        # Create a simple configuration
        config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: copy
                source_expression: input.payload:one
                dest_expression: user_data.temp:my_list
              - type: append
                source_expression: input.payload:one
                dest_expression: user_data.temp:my_list
            input_selection:
              source_expression: user_data.temp
    """
    
        message = Message(payload={"one": 1})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_transforms.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_all" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_invalid_data_type" time="0.000" /><testcase classname="tests.test_message_get_set_data" name="test_get_data_with_complicated_template" time="0.002" /><testcase classname="tests.test_transforms" name="test_missing_dest_expression" time="0.006"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_missing_dest_expression():
        """Test that the program exits if no dest expression is provided"""
        try:
            config_yaml = """
    instance_name: test_instance
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: copy
                source_expression: input.payload:one
            input_selection:
              source_expression: user_data.temp
    """
&gt;           create_connector(config_yaml)

tests/test_transforms.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_missing_source_expression" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_missing_source_expression():
        """Test that the program exits if no source expression is provided"""
        try:
            config_yaml = """
    instance_name: test_instance
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: copy
                dest_expression: user_data.temp:my_list
            input_selection:
              source_expression: user_data.temp
    """
&gt;           create_connector(config_yaml)

tests/test_transforms.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_source_value_as_an_object" time="0.013"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_source_value_as_an_object():
        """Test that a source value can be an object"""
        # Create a simple configuration
        config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: copy
                source_value:
                  one: 1
                  two: 2
                dest_expression: user_data.temp:my_obj
            input_selection:
              source_expression: user_data.temp
    """
    
        message = Message()
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_transforms.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_message_get_set_data" name="test_set_data_user_data_add_more_to_existing" time="0.001" /><testcase classname="tests.test_timer_input" name="test_with_skip_timer" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.timer_input: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'timer_input', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'timer_input'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_with_skip_timer():
        """Create a simple timer input component with a catchup timer."""
        config_yaml = """
    log:
      log_file_level: DEBUG
      log_file: solace_ai_connector.log
    flows:
      - name: test_flow
        components:
          - component_name: timer_input
            component_module: timer_input
            component_config:
              interval_ms: 500
              skip_messages_if_behind: true
    """
    
&gt;       connector, flows = create_test_flows(config_yaml, queue_size=1)

tests/test_timer_input.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'timer_input', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.timer_input: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_transform_with_run_component_test_with_static_import" time="0.001"><failure message="AttributeError: module 'solace_ai_connector' has no attribute 'components'">def test_transform_with_run_component_test_with_static_import():
        """This test is actually testing the test infrastructure method: run_component_test"""
    
        def validation_func(output_data, output_message, _input_message):
            assert output_data == ["Hello, World!"]
            assert output_message[0].get_data("user_data.temp") == {
                "payload": {"text": "Hello, World!", "greeting": "Static Greeting!"}
            }
    
        run_component_test(
&gt;           solace_ai_connector.components.general.pass_through,
            validation_func,
            input_data={"text": "Hello, World!"},
            input_transforms=[
                {
                    "type": "copy",
                    "source_expression": "input.payload",
                    "dest_expression": "user_data.temp:payload",
                },
                {
                    "type": "copy",
                    "source_value": "Static Greeting!",
                    "dest_expression": "user_data.temp:payload.greeting",
                },
            ],
            input_selection={"source_expression": "user_data.temp:payload.text"},
        )
E       AttributeError: module 'solace_ai_connector' has no attribute 'components'

tests/test_transforms.py:88: AttributeError</failure></testcase><testcase classname="tests.test_transforms" name="test_map_with_index_transform" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_map_with_index_transform():
        """Test the map transform with index"""
        # Create a simple configuration
        config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: map
                source_list_expression: input.payload:my_list
                source_expression: item:one
                dest_list_expression: user_data.temp:my_list
                dest_expression: my_obj.item
              - type: map
                source_list_expression: input.payload:my_list
                source_expression: index
                dest_list_expression: user_data.temp:my_list
                dest_expression: my_obj.index
            input_selection:
              source_expression: user_data.temp
    """
    
        message = Message(payload={"my_list": [{"one": 1}, {"one": 2}, {"one": 3}]})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_transforms.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_basic_map_transform" time="0.010"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_basic_map_transform():
        """Test the basic map transform"""
        # Create a simple configuration
        config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: map
                source_list_expression: input.payload:my_list
                source_expression: item:one
                dest_list_expression: user_data.temp:my_list
                dest_expression: my_obj.item
              - type: map
                source_list_expression: input.payload:my_list
                source_expression: item
                dest_list_expression: user_data.temp:my_list
                dest_expression: my_obj.full
            input_selection:
              source_expression: user_data.temp
    """
    
        message = Message(payload={"my_list": [{"one": 1}, {"one": 2}, {"one": 3}]})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_transforms.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_basic_copy_transform" time="0.009"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_basic_copy_transform():
        """Test the basic copy transform"""
        # Create a simple configuration
        config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: copy
                source_expression: input.payload
                dest_expression: user_data.temp:payload
              - type: copy
                source_value: "Static Greeting!"
                dest_expression: user_data.temp:payload.greeting
            input_selection:
              source_expression: user_data.temp:payload.text
    """
    
        message = Message(payload={"text": "Hello, World!"})
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_transforms.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_transform_with_unknown_type" time="0.012"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_transform_with_unknown_type():
        """Test that the program exits if a transform has an unknown type"""
        try:
            config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: unknown
                source_expression: input.payload:one
                dest_expression: user_data.temp:my_list
            input_selection:
              source_expression: user_data.temp
    """
&gt;           create_connector(config_yaml)

tests/test_transforms.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_map_with_message_source_expression" time="0.009"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_map_with_message_source_expression():
        """Test the map transform with message source expression"""
        # Create a simple configuration
        config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - type: map
                source_list_expression: input.payload:my_list
                source_expression: item:one
                dest_list_expression: user_data.temp:my_list
                dest_expression: my_obj.item
              - type: map
                source_list_expression: input.payload:my_list
                source_expression: input.payload:my_obj.two
                dest_list_expression: user_data.temp:my_list
                dest_expression: my_obj.my_obj_two
            input_selection:
              source_expression: user_data.temp
    """
    
        message = Message(
            payload={"my_list": [{"one": 1}, {"one": 2}, {"one": 3}], "my_obj": {"two": 2}}
        )
&gt;       output_message = create_and_run_component(config_yaml, message)

tests/test_transforms.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:231: in create_and_run_component
    connector, flow_info = create_test_flows(
src/solace_ai_connector/test_utils/utils_for_test_files.py:164: in create_test_flows
    connector = create_connector(config_or_yaml, error_queue=error_queue)
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase><testcase classname="tests.test_transforms" name="test_transform_without_a_type" time="0.007"><failure message="ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)">module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
&gt;           return importlib.import_module(module)

src/solace_ai_connector/common/utils.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'pass_through', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'pass_through'

../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: ModuleNotFoundError

During handling of the above exception, another exception occurred:

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
&gt;                               return importlib.import_module(full_name)

src/solace_ai_connector/common/utils.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../tmp/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from .inputs_outputs import (
        error_input,
        timer_input,
        broker_input,
        broker_output,
        stdout_output,
        stdin_input,
    )
    
    from .general import (
        user_processor,
        aggregate,
        pass_through,
        delay,
        iterate,
        message_filter,
        parser,
    )
    
    from .general.for_testing import (
        need_ack_input,
        fail,
        give_ack_output,
    )
    
&gt;   from .general.langchain import (
        langchain_embeddings,
        langchain_vector_store_delete,
        langchain_chat_model,
        langchain_chat_model_with_history,
        langchain_vector_store_embedding_index,
        langchain_vector_store_embedding_search,
    )
E     File "/Users/artmorozov/wrk/SolaceDev-solace-ai-connector/src/solace_ai_connector/components/general/langchain/langchain_vector_store_embedding_index.py", line 142
E       match action:
E             ^
E   SyntaxError: invalid syntax

src/solace_ai_connector/components/__init__.py:28: SyntaxError

The above exception was the direct cause of the following exception:

    def test_transform_without_a_type():
        """Test that the program exits if a transform does not have a type"""
        try:
            config_yaml = """
    flows:
      - name: test_flow
        components:
          - component_name: pass_through
            component_module: pass_through
            input_transforms:
              - source_expression: input.payload:one
                dest_expression: user_data.temp:my_list
            input_selection:
              source_expression: user_data.temp
    """
&gt;           create_connector(config_yaml)

tests/test_transforms.py:294: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/solace_ai_connector/test_utils/utils_for_test_files.py:76: in create_connector
    connector.run()
src/solace_ai_connector/solace_ai_connector.py:40: in run
    self.create_flows()
src/solace_ai_connector/solace_ai_connector.py:62: in create_flows
    flow_instance = self.create_flow(flow, index, i)
src/solace_ai_connector/solace_ai_connector.py:72: in create_flow
    return Flow(
src/solace_ai_connector/flow/flow.py:67: in __init__
    self.create_components()
src/solace_ai_connector/flow/flow.py:75: in create_components
    self.create_component_group(component, index)
src/solace_ai_connector/flow/flow.py:98: in create_component_group
    imported_module = import_module(component_module, base_path, component_package)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

module = 'pass_through', base_path = None, component_package = None

    def import_module(module, base_path=None, component_package=None):
        """Import a module by name or return the module object if it's already imported"""
    
        if isinstance(module, types.ModuleType):
            return module
    
        if component_package:
            install_package(component_package)
    
        if base_path:
            if base_path not in sys.path:
                sys.path.append(base_path)
        try:
            return importlib.import_module(module)
        except ModuleNotFoundError as exc:
            # If the module does not have a path associated with it, try
            # importing it from the known prefixes - annoying that this
            # is necessary. It seems you can't dynamically import a module
            # that is listed in an __init__.py file :(
            if "." not in module:
                for prefix_prefix in ["solace_ai_connector", "."]:
                    for prefix in [
                        ".components",
                        ".components.general",
                        ".components.general.for_testing",
                        ".components.general.langchain",
                        ".components.general.openai",
                        ".components.general.websearch",
                        ".components.inputs_outputs",
                        ".components.general.filter",
                        ".transforms",
                        ".common",
                    ]:
                        full_name = f"{prefix_prefix}{prefix}.{module}"
                        try:
                            if full_name.startswith("."):
                                return importlib.import_module(
                                    full_name, package=__package__
                                )
                            else:
                                return importlib.import_module(full_name)
                        except ModuleNotFoundError as e:
                            name = str(e.name)
                            if (
                                name != "solace_ai_connector"
                                and name.split(".")[-1] != full_name.split(".")[-1]
                            ):
                                raise e
                        except Exception as e:
&gt;                           raise ImportError(
                                f"Module load error for {full_name}: {e}"
                            ) from e
E                           ImportError: Module load error for solace_ai_connector.components.pass_through: invalid syntax (langchain_vector_store_embedding_index.py, line 142)

src/solace_ai_connector/common/utils.py:152: ImportError</failure></testcase></testsuite></testsuites>